"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
var path_1 = __importDefault(require("path"));
var typescript_1 = __importStar(require("typescript"));
var fs_1 = __importDefault(require("fs"));
var dbg_1 = require("./dbg");
var print_1 = require("./print");
var shared_1 = require("./shared");
var chalk_1 = __importDefault(require("chalk"));
var nameof_1 = require("./nameof");
var git_1 = require("./git");
var sourceText = fs_1.default.readFileSync(path_1.default.join(__dirname, "..", "index.d.ts"), "utf8");
function isModule(sourceFile) {
    return sourceFile.text === sourceText;
}
function isModuleImportExpression(node, program) {
    if (!typescript_1.default.isImportDeclaration(node)) {
        return false;
    }
    if (!node.importClause) {
        return false;
    }
    var namedBindings = node.importClause.namedBindings;
    if (!node.importClause.name && !namedBindings) {
        return false;
    }
    var importSymbol = program.getTypeChecker().getSymbolAtLocation(node.moduleSpecifier);
    if (!importSymbol || !importSymbol.valueDeclaration || !isModule(importSymbol.valueDeclaration.getSourceFile())) {
        return false;
    }
    return true;
}
function visitNodeAndChildren(node, program, context, config) {
    return typescript_1.default.visitEachChild(visitNode(node, program, config), function (childNode) { return visitNodeAndChildren(childNode, program, context, config); }, context);
}
var MacroFunctionName = {
    dbg: "$dbg",
    print: "$print",
    warn: "$warn",
    commitId: "$commitId",
    git: "$git",
    nameof: "$nameof",
};
function handleDebugCallExpression(node, functionName, program, _a) {
    var enabled = _a.enabled, verbose = _a.verbose;
    if (verbose)
        console.log((0, shared_1.formatTransformerDebug)("Handling call to macro " + chalk_1.default.yellow(functionName), node));
    switch (functionName) {
        case MacroFunctionName.dbg: {
            var _b = node.arguments, expression = _b[0], customHandler = _b[1];
            if (typescript_1.default.isExpressionStatement(node.parent) && customHandler === undefined) {
                return enabled
                    ? (0, dbg_1.transformToInlineDebugPrint)(expression)
                    : typescript_1.default.isCallExpression(expression)
                        ? expression
                        : typescript_1.factory.createVoidExpression(typescript_1.factory.createIdentifier("undefined"));
            }
            return enabled ? (0, dbg_1.transformToIIFEDebugPrint)(expression, customHandler, program) : expression;
        }
        case MacroFunctionName.commitId: {
            return (0, git_1.transformCommitId)(node);
        }
        case MacroFunctionName.git: {
            return (0, git_1.transformGit)(node);
        }
        case MacroFunctionName.print: {
            return enabled ? (0, print_1.transformPrint)(node) : typescript_1.factory.createVoidExpression(typescript_1.factory.createIdentifier("undefined"));
        }
        case MacroFunctionName.warn: {
            return enabled
                ? (0, print_1.transformWarning)(node)
                : typescript_1.factory.createVoidExpression(typescript_1.factory.createIdentifier("undefined"));
        }
        case MacroFunctionName.nameof: {
            if (typescript_1.default.isExpressionStatement(node.parent)) {
                console.log((0, shared_1.formatTransformerWarning)("Call to " + node.getText() + ", which is not used anywhere. It has been stripped.", node));
                return typescript_1.factory.createVoidExpression(typescript_1.factory.createIdentifier("undefined"));
            }
            else {
                return (0, nameof_1.transformNameOf)(node, program);
            }
        }
        default:
            throw (0, shared_1.formatTransformerDiagnostic)("function " + chalk_1.default.yellow(functionName) + " cannot be handled by this version of rbxts-transform-debug");
    }
}
function visitCallExpression(node, program, config) {
    var typeChecker = program.getTypeChecker();
    var signature = typeChecker.getResolvedSignature(node);
    if (!signature) {
        return node;
    }
    var declaration = signature.declaration;
    if (!declaration || typescript_1.default.isJSDocSignature(declaration) || !isModule(declaration.getSourceFile())) {
        return node;
    }
    var functionName = declaration.name && declaration.name.getText();
    if (!functionName) {
        return node;
    }
    return handleDebugCallExpression(node, functionName, program, config);
}
function visitNode(node, program, config) {
    if (isModuleImportExpression(node, program)) {
        var importClause = node.importClause;
        if (importClause !== undefined && importClause.isTypeOnly) {
            return node;
        }
        if (importClause !== undefined) {
            return typescript_1.factory.updateImportDeclaration(node, undefined, undefined, typescript_1.factory.updateImportClause(importClause, true, importClause.name, importClause.namedBindings), node.moduleSpecifier);
        }
        return typescript_1.factory.createExportDeclaration(undefined, undefined, false, typescript_1.default.factory.createNamedExports([]), undefined);
    }
    if (typescript_1.default.isCallExpression(node)) {
        return visitCallExpression(node, program, config);
    }
    return node;
}
var DEFAULTS = {
    enabled: true,
};
function transform(program, userConfiguration) {
    userConfiguration = __assign(__assign({}, DEFAULTS), userConfiguration);
    if (userConfiguration.environmentRequires) {
        for (var _i = 0, _a = Object.entries(userConfiguration.environmentRequires); _i < _a.length; _i++) {
            var _b = _a[_i], k = _b[0], v = _b[1];
            if ((typeof v === "boolean" && process.env[k] === undefined) ||
                (typeof v === "string" && process.env[k] !== v)) {
                userConfiguration.enabled = false;
            }
        }
    }
    if (userConfiguration.verbose) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        console.log((0, shared_1.formatTransformerDebug)("Running version " + require("../package.json").version));
        console.log((0, shared_1.formatTransformerDebug)("Macros enabled: " + chalk_1.default.cyan(userConfiguration.enabled)));
    }
    return function (context) { return function (file) {
        return visitNodeAndChildren(file, program, context, userConfiguration);
    }; };
}
exports.default = transform;
